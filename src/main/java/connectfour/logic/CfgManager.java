package connectfour.logic;

import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;

import connectfour.model.Configuration;
import connectfour.model.Game;
import connectfour.model.Level;
import connectfour.model.SavedGame;

public class CfgManager {

	/*
	 * caricamento delle variabili secondo le impostazioni predefinite del file di
	 * configurazione cfg presente nella cartella di installazione del gioco
	 */
	public Configuration loadCfg(File cfg) {
		boolean singlePlayerGame = true, usePlayer1 = true;
		String player1Name = "", player2Name = "", hostname = "";
		Level level = Level.NORMAL;

		String tmp = new String();
		String cfr = new String();
		try {
			BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(cfg)));
			do {
				tmp = r.readLine();
				tmp = tmp.trim();
				if (tmp.startsWith("begin") || tmp.startsWith("//"))
					;
				else {
					/* caso: giocatore singolo, viene inizializzato */
					cfr = "singlePlayer";
					if (tmp.startsWith(cfr)) {
						singlePlayerGame = true;
						if (tmp.endsWith("= 1;")) {
							usePlayer1 = true;
						}
						if (tmp.endsWith("= 2;")) {
							usePlayer1 = false;
						}
					}

					/* caso: multigiocatore */
					cfr = "multiPlayer";
					if (tmp.startsWith(cfr) && tmp.endsWith("= 1;")) {
						singlePlayerGame = false;
					}

					/*
					 * abilita il gioco in rete cfr = "network"; if(tmp.startsWith(cfr) &&
					 * tmp.endsWith("= 1;")) network = true; else if(tmp.startsWith(cfr) &&
					 * tmp.endsWith("= 0;")) network = false;
					 */

					/* imposta il nome del giocatore 1 */
					cfr = "name1";
					if (tmp.startsWith(cfr)) {
						tmp = tmp.substring(tmp.indexOf("'") + 1, tmp.lastIndexOf("'"));
						player1Name = tmp;
					}

					/* imposta il nome del giocatore 2 */
					cfr = "name2";
					if (tmp.startsWith(cfr)) {
						tmp = tmp.substring(tmp.indexOf("'") + 1, tmp.lastIndexOf("'"));
						player2Name = tmp;
					}

					/* configura IP */
					cfr = "ip";
					if (tmp.startsWith(cfr)) {
						tmp = tmp.substring(tmp.indexOf("'") + 1, tmp.lastIndexOf("'"));
						hostname = tmp;
					}

					/* configura colori */

					/* altre opzioni */
					cfr = "level";
					if (tmp.startsWith(cfr)) {
						if (tmp.endsWith("= 4;"))
							// game.setLevel(Level.NORMAL);
							level = Level.NORMAL;
						else
							// game.setLevel(Level.HARD);
							level = Level.HARD;
					}

				}
			} while (!tmp.equals("end"));
			r.close();
		} catch (Exception e) {
			System.err.println(e);
		}
		return new Configuration(singlePlayerGame, usePlayer1, player1Name, player2Name, hostname, level);
	}

	public void saveCfg(Game game) {
		String gamePath = new File("").getAbsolutePath();
		File saveCfg = new File(gamePath + "\\save.txt");
		if (saveCfg.exists())
			saveCfg.delete();

		if (!game.isGameOver() && game.getMoves()[0] != -1) {
			/*
			 * salva la partita prima di uscire, in modo che essa sia recuperabile al
			 * seguente avvio del programma
			 */
			try {
				saveCfg.createNewFile();
				PrintStream writer = null;
				try {
					writer = new PrintStream(new FileOutputStream(saveCfg));
				} catch (FileNotFoundException e) {
					e.printStackTrace();
					System.exit(-1);
				}
				for (int i = game.getMarker(); i < 42; i++) {
					game.getMoves()[i] = -1;
				}
				for (int i = 0; i < 42; i++)
					if (game.getMoves()[i] != -1)
						writer.print(game.getMoves()[i]);
				writer.print('*');
				writer.close();
			} catch (IOException e) {
				e.printStackTrace();
				System.exit(-1);
			}
		}

		/* salvataggio di tutte le variabili al loro ultimo settaggio */
		File cfg = new File(gamePath + "\\cfg.txt");
		PrintStream writer;
		try {
			writer = new PrintStream(new FileOutputStream(cfg));
			writer.println("//Please do not edit this file\n\nbegin\n\n//player");
			if ((game.getPlayer1().isHuman() && !game.getPlayer2().isHuman())
					|| (!game.getPlayer1().isHuman() && game.getPlayer2().isHuman())) {
				writer.println("multiPlayer = 0;");
				if (game.getPlayer1().isHuman())
					/* impostazione salvata a modalita' single player come giallo */
					writer.println("singlePlayer = 1;");
				else
					/* impostazione salvata a modalita' single player come rosso */
					writer.println("singlePlayer = 2;");
			} else {
				/* impostazione salvata a modalita' multigiocatore su un pc */
				writer.println("singlePlayer = 0;");
				writer.println("multiPlayer = 1;");
			}
			/* nomi dei giocatori */
			writer.println("name1 = \'" + game.getPlayer1().getName() + "\';");
			writer.println("name2 = \'" + game.getPlayer2().getName() + "\';");
			writer.println("\n//network");
			/* ultimo avversario in rete */
			if (game.isNetworkGame()) {
				writer.println("ip = \'" + game.getHostname() + "\';");
			} else {
				writer.println("ip = \'\';");
			}
			writer.println("\n//game");
			writer.println(String.format("level = %d;", game.getLevel().getDifficulty()));
			writer.println("\nend");
			writer.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.exit(-1);
		}
	}

	/*
	 * caricamento della lista di mosse nell'array moves: l'array contiene i valori
	 * delle colonne giocate e -1 in eventuali mosse future non giocate ancora;
	 * l'indice marker segue l'ultima mossa valida
	 */
	public SavedGame loadMoveList(File saved) {
		int i = -1;
		int[] moves = new int[42];
		int marker = 0;
		try {
			DataInputStream reader = new DataInputStream(new FileInputStream(saved));
			do {
				i++;
				moves[i] = (reader.read() - 48);
			} while (moves[i] != -6 && i < 41);
			reader.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		for (int j = i; j < 42; j++)
			moves[j] = -1;
		for (marker = 0; moves[marker] != -1; marker++)
			;

		return new SavedGame(moves, marker);
	}
}
